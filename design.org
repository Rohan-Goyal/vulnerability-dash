#+title: Superset Project
# #+options: toc:nil
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
* Spec
** Problem Statement
Create a consolidated dashboard of vulnerabilities which could be present in the codebase. The vulnerabilities can be fetched by enabling Dependabot in Github and connecting the Github account to a Synk account. Please make sure that the Github account has code repositories.
** References
- https://snyk.io
- https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates
** Deliverables
1. Please create a writeup on the approach and technologies being used to achieve the above.
2. Please share the code repository once implemented.

* Process Outline
- Write as much of it in Python as possible.
** Retrieving Data
- Lookup API docs, and go through the setup.
- Run quick experiments in Postman to get a sense of pitfalls/quirks, and the structure of returned data.
- Build API requests that get a superset of the data I need, use PyGithub and Pysnyk to handle the actual API calls.
- Collect JSON stubs for project vulnerabilities, save them as files to use as a supplementary data source (to get around the API restrictions)
** Structuring/Processing Data
- Choose which fields I want to keep, and which to discard (this is a design decision which may change over time, so make it as easy as possible to change)
- Turn each vulnerability into a discrete JSON object associated with a project, rather than having a project associated with a list of vulnerabilities
- Utility functions for pulling out that data from a messy nested JSON.
- Translate data into intermediate format if required (eg: Mapping severity labels to integers, handling URLs/references)
- Generate processed data, such as any aggregation I want to run.
** Presenting
- Options for frontend are web page or DB in Notion (based on my proficiencies/experiences)
- Notion seems the strongest, since it has a sophisticated API, can be used as a bug tracker for projects, and it means we get a nice UI + search and filter tools for free.
** Features/Bells and Whistles
- Export summary as JSON via CLI
* Data Presented
*** Abstract/High-Level/Overview
- Count, broken down by repo
- Aggregate stats: Number of vulnerabilities, averages of everything we can average.
- Overall color and grade based on number and severity of vulnerabilities.
*** For individual vulnerabilities
- Project name and repo link
- Location: Source file, line number
- Severity color
- Summary of issue (first sentence)
- Either package name or line number, depending on type of vulnerability
- Status: Handled, dismissed, open.
- Date discovered/updated
- CVE/GHSA link, if applicable
*** Fixes/Recommendations/Action Items
- This is something like a separate tab from the main view.
- Only for open vulnerabilities (obviously).
- Packages and the fixed version number to update to.
- For Snyk, try to pull that info from the site or JSON stubs.
- Link to learn.snyk.io?
* Algorithms
*** Overall Flow (User-facing)
- We have a list of repositories hardcoded/from file
- Retrieve all relevant data, store in intermediate format (processing+aggregation, etc.)
- Construct a Notion database from the intermediate representation on a preselected notion page.
- Add vulnerabilities to the DB as elems.
- User selects a repository or applies filters (via the Notion UI)
- User can run the app via CLI to rebuild the DB. Or option to make it a regular thing, like a cron job or a button for it in the UI.
*** Computations: Aggregation, overall scoring
- This is largely ad-hoc. Log-scale roughly, so a grade N vuln has score $2^N$, or so. Make this flexible, so don't hardcode the specific scoring mechanism.
- Present this "weighted sum", grade it somewhat arbitrarily.
- Average number and severity (per-repo, and for the entire set)

* Considering choices of frontend
- NOTE: This section is mostly just me thinking out loud
- Web feels the most natural, given my experience.
- Reuse an idea I've used before: Local webpage. So basically use a python script to generate a webpage dynamically and serve it over localhost.
- An alternative would be to do something more sophisticated with a JS frontend, but this is more of a `stretch goal', depending on how long it takes me to get the data.
- Programatically constructed Notion.so page? This is possible, but requires recomputing every time. Which is honestly fine. Notion is basically a cheap database with a builtin frontend, there are worse things to use for this.
- https://github.com/ramnes/notion-sdk-py/blob/main/examples/databases/create_database.py shows how to create a notion DB based on python dictionaries as data, so that's at least feasible.
- https://dev.to/maeganwilson_/how-to-use-notion-as-an-issue-tracker-3oab establishes that notion is definitely usable for sophisticated stuff like bug tracking.
- Notion also has a "notion.site" option for turning notebooks into shareable webpages, so we can get all the good stuff of a webpage without actually writing any JS.
- Notion formulas exist, so aggregation is possible even if the neat display is hard. Actually we can just do computations in python and share the aggregate data to notion, perhaps in a separate tab/view.
- Notion DB also means we get search and filter for free.
- So either a notion DB with aggregation (might be hard), or a classic python local webserver.
- Confession: This is largely based on the fact that I've wanted to explore the Notion API ever since it became public, and this is a good chance to do so.
* TODO
- Figure out structure of dependabot JSON
- Notion DB creation, and testing
- Stub the snyk JSON
* Feedback
- That's a bummer on the free vs. organization account. You can manually stub the json responses from the Synk UI after you log in. For example, you can take the response from the vulnerable-projects endpoint & project endpoint and store it as stubs for the rest of the process to work.
- `https://app.snyk.io/registry/org/<organization_name>/dashboard/vulnerable-projects`
- `https://app.snyk.io/org/<organization_name>/project/<project_uuid>/vulns/<vulnerability_uuid>?latest=true`
* Questions, redux
- Mutation: Do things like ignore vuln from the dashboard, or just view?
- Snyk: Still facing some issues on manually stubbing.
* TODO
- Snyk
- Async for Notion+Git APIs
- Way to easily recreate the DB
* DONE
- Refactor populate db to check the DB values fo
- Refactor plan: When =populate_vuln_db= is called, write current time to a file. Then for every vuln, if date_discovered (in github) > last_write_time, add it in. DONE
