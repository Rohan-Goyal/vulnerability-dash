#!/usr/bin/env ipython3
from dataclasses import dataclass
from enum import Enum
from os import access
from pprint import pprint
import subprocess
from subprocess import Popen, PIPE
from types import FunctionType
from typing import Generator, List
from github import Github
from subprocess import run
import json
from notion_client import Client
import notion_client
from notion_client.typing import SyncAsync
from notion_database.database import Database
from datetime import datetime, date


def load_token(path):
    with open(path,"r") as f:
        return f.read()

with open("github_data.json", "r") as stuff:
    DATA = json.load(stuff)


read_token = (
    lambda: "61092fbb-817d-40f8-be1f-0659358fb8ab"
)  # Placeholder for now, replace with more secure.
org_id = lambda: "cde0c9ab-d76d-4ef2-802c-5799b036f86f"
VULN_SCHEMA = "vuln_schema.json"

GITHUB_TOKEN = load_token(".github_token")
name = "Rohan-Goyal/PyMun"
gh = Github(GITHUB_TOKEN)
repo = gh.get_repo(name)
NOTION_TOKEN = "secret_rUv9VldkW1a17gLhfUo3LD4L2rrvAPEdEHsSt9mpTtb"
NOTION_DB = "e59893b02666431eaa21cb27262c553d"
NOTION_PAGE = (
    "40d5c90a3c7847f5a360fc6ef756781a"  # TODO: Get way for users to supply this.
)
UPDATE_FILE = ".vulnerability_dash"

notion = Client(auth=NOTION_TOKEN)

# Generate list of repos:
USERNAME = "Rohan-Goyal"
USER = gh.get_user("Rohan-Goyal")
REPOS = USER.get_repos()


def get_output(cmd: str) -> str:
    """Run a command in the default shell, and return the output as a string

    :param cmd: The command to run, as plaintext
    :returns: The output string from running the command (including intermediate output)

    """
    with Popen(cmd, stdout=PIPE, stderr=None, shell=True) as process:
        output = process.communicate()[0].decode("utf-8")
        return output


def hash_dict(d: dict) -> int:
    tupled = tuple([(k, v) for k, v in d])
    return hash(tupled)


class Status(Enum):
    HANDLED = "handled"
    DISMISSED = "dismissed"
    OPEN = "open"
    UNKNOWN = ""

    @staticmethod
    def get_status(s: str):
        for status in list(Status):
            if status.value == s.lower():
                return status
        return Status.UNKNOWN

    def to_string(self) -> str:
        return self.value.capitalize()


class Severity(Enum):
    CRITICAL = 3
    HIGH = 2
    MEDIUM = 1
    LOW = 0

    @staticmethod
    def get_severity(s: str):
        data = {
            "critical": Severity.CRITICAL,
            "high": Severity.HIGH,
            "medium": Severity.MEDIUM,
            "low": Severity.LOW,
        }
        return data[s.lower()]

    def to_string(severity):
        return ["Low", "Medium", "High", "Critical"][severity.value]


@dataclass
class Vulnerability:
    owner: str
    repo: str
    severity: Severity  # Scale from 1-5 probably
    summary: str
    package: str
    fixed_version: str
    state: Status  # One of handled/dismissed/open
    created: str  # Should be datetime
    cve: str
    exploit_maturity: str
    learn_more: str

    @classmethod
    def get_parsed_alerts(cls, data=None) -> Generator:
        """Get a set of alerts for all relevant repos, parsed into Vulnerability objects.

        :param cls: The kind of vulnerability to retrieve and parse - GitHub or Snyk. Implicit in the class/object you call from.
        :param data: Optionally, supply a List[dict] from which to parse rather than running the API call.
        :returns: A generator of Vulnerability objects constructing from retrieved alerts.

        """

        alerts = data or cls.get_all_alerts()
        for alert in alerts:
            yield cls.parse_alert(alert)

    @staticmethod
    def uniques(vulns: List) -> set:
        """Given a list of Vulnerabilities, retains only those with unique CVEs to avoid duplication.

        :param vulns: A list of vulnerabilities
        :returns: A set of vulnerabilities where each CVE is unique.

        """

        return set(vulns)

    def __eq__(self, __o: object) -> bool:
        return isinstance(__o, Vulnerability) and __o.cve == self.cve

    def __hash__(self) -> int:
        return hash_dict(self.__dict__)


@dataclass
class GithubVulnerability(Vulnerability):
    SEVERITY_SCORES = {"critical": 3, "high": 2, "medium": 1, "low": 0}

    @staticmethod
    def get_all_alerts(
        owner=USERNAME, repos=REPOS, token=GITHUB_TOKEN
    ) -> List[Vulnerability]:
        return flatten(
            [GithubVulnerability.get_alerts(owner, repo.name, token) for repo in repos]
        )

    @staticmethod
    def get_alerts(owner: str, repo: str, token=GITHUB_TOKEN) -> List[Vulnerability]:
        """Get a list of Dependabot alerts as JSON. Uses curl as a hack because dependabot API is in public beta.


        :param owner: The name of the user/owner of the relevant repos
        :param repo: The repo name as on GitHub
        :param token: Auth token for the GitHub API
        :returns: A list of dependency alerts as dictionaries, based on the JSON response of the API.

        """

        base = "https://api.github.com"
        endpoint = f"/repos/{owner}/{repo}/dependabot/alerts"
        command = f"""curl -s -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer {token}" -H "X-GitHub-Api-Version: 2022-11-28" {base+endpoint}"""
        result = get_output(command)
        out = json.loads(result)
        if not isinstance(out, list):
            return []
        return out

    @staticmethod
    def score_severity(severity: str) -> int:
        return GithubVulnerability.SEVERITY_SCORES[severity]

    @staticmethod
    def parse_alert(response: dict) -> Vulnerability:
        """Given a portion of the API response representing a single vulnerability, extract relevant fields and create a Vulnerability object.

        :param api_response:
        :returns: GitHubVulnerability object representing the passed-in dependabot alert.
        """
        owner = extract_user_name(response["url"])
        repo = extract_repo_name(response["url"])
        state = Status.get_status(response["state"])
        advisory = response["security_advisory"]
        cve = advisory["cve_id"]
        severity = Severity.get_severity(advisory["severity"])
        summary = get_first_sentence(advisory["summary"])
        vulnerabilities = advisory["vulnerabilities"][0]
        package = vulnerabilities["package"]["name"]
        # created = datetime.fromisoformat(response["created_at"][:-1])
        created = response["created_at"][:-1]
        version = vulnerabilities["first_patched_version"]["identifier"]
        learn_more = response["url"]
        return GithubVulnerability(
            owner=owner,
            repo=repo,
            state=state,
            severity=severity,
            summary=summary,
            package=package,
            created=created,
            fixed_version=version,
            cve=cve,
            exploit_maturity="-",
            learn_more=learn_more,
        )


@dataclass
class SnykVulnerability(Vulnerability):
    @staticmethod
    def get_alerts():
        """TODO describe function

        :returns:

        """

    pass


def read_properties_object(schema: str) -> dict:
    """Read a schema stored as a JSON file, and translate that into a valid property object for a notion DB

    :param schema: The name/path of the JSON file where the schema is defined
    :returns: A dictionary representing a valid properties value for a notion DB.
    """
    with open(schema, "r") as s:
        properties = json.load(s)
        # TODO Optional json tinkering/processing. Should be minimal
    return properties


def create_notion_db(parent_id, db_name: str, schema: str) -> dict:
    """Create a notion DB on the page specified by PARENT_ID, structured according to SCHEMA, and return a Dict representing the constructed DB.
    :param parent_id: ID of the page to create the DB on.
    :param db_name: Intended name of the DB
    :param schema: Path to JSON file containing the schema for the DB
    :returns: Dictionary representing the database as a notion object
    """
    title = [{"type": "text", "text": {"content": db_name}}]
    icon = {"type": "emoji", "emoji": "ðŸŽ‰"}
    parent = {"type": "page_id", "page_id": parent_id}
    properties = read_properties_object(schema)
    return notion.databases.create(
        parent=parent, title=title, properties=properties, icon=icon
    )


def get_id(db) -> str:
    """Get the ID of a Notion database.

    :param db: Object representing a notion database as returned by the Notion Client.
    :returns: ID of that DB
    """
    return db["id"]


def create_vuln_db(parent=NOTION_PAGE) -> str:
    """Create and populate a Notion DB of repo vulnerabilities on the specified page, and return the ID of the new DB.

    :param parent: ID of the notion page where the DB should be created
    :returns: ID of the created database.

    """
    database = create_notion_db(parent, "Vulnerabilities", VULN_SCHEMA)
    populate_vuln_db(get_id(database))
    return get_id(database)


def populate_vuln_db(db_id=NOTION_DB) -> List[dict]:
    """Given a pointer to a Notion DB, populate it with vulnerability data from both Dependabot and Snyk. Only add new vulnerabilities (those created since the last update)
    :param db_id: The ID of the Notion database to Populate
    :returns: A list of Page objects, each representing a created page/entry.

    """
    created_pages = []
    last_updated = get_last_update_time()
    set_last_update_time(datetime.now())
    new_alerts = filter(
        lambda alert: alert.created >= last_updated,
        GithubVulnerability.get_parsed_alerts(),
    )
    print(last_updated)
    for alert in new_alerts:
        print(alert.created)
        properties = create_entry(alert)
        page = notion.pages.create(parent={"database_id": db_id}, properties=properties)
        created_pages.append(page)
    return created_pages


def get_last_update_time(path=UPDATE_FILE) -> str:
    try:
        with open(path, "r") as f:
            return f.read()
    except FileNotFoundError:
        return datetime.fromtimestamp(0).isoformat()


def set_last_update_time(time: datetime, path=UPDATE_FILE):
    with open(path, "w+") as f:
        f.write(time.isoformat())

def clear_last_update_time(path=UPDATE_FILE):
    set_last_update_time(datetime.fromtimestamp(0))

def wrap_in_rich_text(s: str, url: None | str = None) -> List[dict]:
    if url:
        return [
            {
                "type": "text",
                "text": {"content": s, "link": {"url": url}},
            },
        ]
    else:
        return [
            {
                "type": "text",
                "text": {"content": s},
            },
        ]


def create_entry(alert: Vulnerability) -> dict:
    """Translate an alert into a Notion properties object that respects the vulnerability schema.

    :param alert: A github vulnerability object to be translated
    :returns: A dictionary containing the Vulnerability data, transformed to respect the schema of VULN_DB.

    """
    return {
        "Severity": {"select": {"name": alert.severity.to_string()}},
        "Package": {"rich_text": wrap_in_rich_text(alert.package.capitalize())},
        "Status": {"select": {"name": alert.state.to_string()}},
        "Date Discovered": {"date": {"start": alert.created}},
        "CVE": {
            "rich_text": wrap_in_rich_text(
                alert.cve, f"https://www.cve.org/CVERecord?id={alert.cve}"
            )
        },
        "Patched Version": {"rich_text": wrap_in_rich_text(alert.fixed_version)},
        "Project": {
            "title": wrap_in_rich_text(
                alert.repo, f"github.com/{alert.owner}/{alert.repo}"
            )
        },
        "Summary": {"rich_text": wrap_in_rich_text(alert.summary)},
    }


def get_first_sentence(s: str) -> str:
    return s.split(".")[0]


def extract_repo_name(url: str) -> str:
    data = url.split("/repos/")[1]
    return data.split("/")[1]


def extract_user_name(url: str) -> str:
    data = url.split("/repos/")[1]
    return data.split("/")[0]


def flatten(lst: List[List]) -> List:
    return [item for sublist in lst for item in sublist]


def main():
    """Retrieve GH and Snyk data, process into dataclasses, create notion DB, populate notion DB, open DB in notion?

    :returns:

    """


x = GithubVulnerability.get_parsed_alerts(DATA)
# print(create_vuln_db())
page_id = "fee2324dc4c94a7b89c8cc13d18775c2"
pages = populate_vuln_db(db_id)
pprint(pages)
