#!/usr/bin/env ipython3
from dataclasses import dataclass
from enum import Enum
from pprint import pprint
from subprocess import Popen, PIPE
from types import FunctionType
from typing import Generator, List, Set, Dict, ClassVar
from github import Github
import json
from notion_client import Client
from notion_client.typing import SyncAsync
from datetime import datetime
import webbrowser


def load_data(path):
    with open(path, "r") as f:
        return f.read().strip()


# Tokens
SNYK_TOKEN = load_data(".snyk_token")
GITHUB_TOKEN = load_data(".github_token")
NOTION_TOKEN = load_data(".notion_token")

# Files and data
VULN_SCHEMA = "vuln_schema.json"  # Path to DB schema
UPDATE_FILE = ".vulnerability_dash"
NOTION_DB_PATH = ".notion_db"
NOTION_DB = load_data(NOTION_DB_PATH)
NOTION_PAGE = ""

with open("github_data.json", "r") as stuff:
    DATA = json.load(stuff)

# API Clients
GH_CLIENT = Github(GITHUB_TOKEN)
NOTION_CLIENT = Client(auth=NOTION_TOKEN)

# Data
SNYK_ORG_ID = "cde0c9ab-d76d-4ef2-802c-5799b036f86f"
USERNAME = "Rohan-Goyal"
USER = GH_CLIENT.get_user("Rohan-Goyal")
REPOS = USER.get_repos()


class Status(Enum):
    HANDLED = "handled"
    DISMISSED = "dismissed"
    OPEN = "open"
    UNKNOWN = ""

    @staticmethod
    def get_status(s: str):
        """Maps a string `s' to a Status object.

        :param s:
        :returns:

        """

        for status in list(Status):
            if status.value == s.lower():
                return status
        return Status.UNKNOWN

    def to_string(self) -> str:
        """Return the string representation of the Status object SELF.

        :returns:

        """

        return self.value.capitalize()


class Severity(Enum):
    CRITICAL = 3
    HIGH = 2
    MEDIUM = 1
    LOW = 0

    @staticmethod
    def get_severity(s: str):
        """Maps a string `s` to a Severity object.

        :param s:
        :returns:

        """
        data = {
            "critical": Severity.CRITICAL,
            "high": Severity.HIGH,
            "medium": Severity.MEDIUM,
            "low": Severity.LOW,
        }
        return data[s.lower()]

    def to_string(self) -> str:
        # TODO docstring
        return ["Low", "Medium", "High", "Critical"][self.value]


@dataclass
class Vulnerability:
    owner: str
    repo: str
    severity: Severity  # Scale from 1-5 probably
    summary: str
    package: str
    fixed_version: str
    state: Status  # One of handled/dismissed/open
    created: str  # Should be datetime
    ghsa: str
    exploit_maturity: str
    more_info: str

    @classmethod
    def get_parsed_alerts(cls, data=None) -> Generator:
        """Get a set of alerts for all relevant repos, parsed into Vulnerability objects.

        :param cls: The kind of vulnerability to retrieve and parse - GitHub or Snyk. Implicit in the class/object you call from.
        :param data: Optionally, supply a List[dict] from which to parse rather than running the API call.
        :returns: A generator of Vulnerability objects constructing from retrieved alerts.

        """

        alerts = data or cls.get_all_alerts()
        for alert in alerts:
            yield cls.parse_alert(alert)

    @staticmethod
    def uniques(vulns: List) -> Set:
        """Given a list of Vulnerabilities, retains only those with unique CVEs to avoid duplication.

        :param vulns: A list of vulnerabilities
        :returns: A set of vulnerabilities where each CVE is unique.

        """
        return set(vulns)


@dataclass
class GithubVulnerability(Vulnerability):
    SEVERITY_SCORES = {"critical": 3, "high": 2, "medium": 1, "low": 0}

    @staticmethod
    def transform_url(url: str) -> str:
        """Transform an api.github.com link to a dependabot alert into one that can be read in a web browser
        https://api.github.com/repos/Rohan-Goyal/vuln-test/dependabot/alerts/1
        https://github.com/Rohan-Goyal/vuln-test/security/dependabot/

                :param url:
                :returns:

        """
        return (
            url.replace("api.github.com", "github.com")
            .replace("repos/", "")
            .replace("dependabot/alerts", "security/dependabot")
        )

    @staticmethod
    def get_all_alerts(
        owner=USERNAME, repos=REPOS, token=GITHUB_TOKEN
    ) -> List[Vulnerability]:
        # TODO docstring

        return flatten(
            [GithubVulnerability.get_alerts(owner, repo.name, token) for repo in repos]
        )

    @staticmethod
    def get_alerts(owner: str, repo: str, token=GITHUB_TOKEN) -> List[Vulnerability]:
        """Get a list of Dependabot alerts as JSON. Uses curl as a hack because dependabot API is in public beta.


        :param owner: The name of the user/owner of the relevant repos
        :param repo: The repo name as on GitHub
        :param token: Auth token for the GitHub API
        :returns: A list of dependency alerts as dictionaries, based on the JSON response of the API.

        """

        base = "https://api.github.com"
        endpoint = f"/repos/{owner}/{repo}/dependabot/alerts"
        command = f"""curl -s -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer {token}" -H "X-GitHub-Api-Version: 2022-11-28" {base+endpoint}"""
        result = get_output(command)
        out = json.loads(result)
        if not isinstance(out, list):
            return []
        return out

    @staticmethod
    def parse_alert(response: Dict) -> Vulnerability:
        """Given a portion of the API response representing a single vulnerability, extract relevant fields and create a Vulnerability object.

        :param response: Dictionary from parsing the API response.
        :returns: GitHubVulnerability object representing the passed-in dependabot alert.
        """
        owner = extract_user_name(response["url"])
        repo = extract_repo_name(response["url"])
        state = Status.get_status(response["state"])
        advisory = response["security_advisory"]
        cve = advisory["cve_id"]
        ghsa=advisory["ghsa_id"]
        severity = Severity.get_severity(advisory["severity"])
        summary = get_first_sentence(advisory["summary"])
        vulnerabilities = advisory["vulnerabilities"][0]
        package = vulnerabilities["package"]["name"]
        # created = datetime.fromisoformat(response["created_at"][:-1])
        created = response["created_at"][:-1]
        version = vulnerabilities["first_patched_version"]["identifier"]
        more_info = GithubVulnerability.transform_url(response["url"])
        if ghsa==None:
            pprint(response)
        return GithubVulnerability(
            owner=owner,
            repo=repo,
            state=state,
            severity=severity,
            summary=summary,
            package=package,
            created=created,
            fixed_version=version,
            ghsa=ghsa,
            exploit_maturity="-",
            more_info=more_info,
        )


@dataclass
class SnykVulnerability(Vulnerability):
    @staticmethod
    def get_alerts():
        """TODO describe function

        :returns:

        """

    pass


def read_properties_object(schema: str) -> Dict:
    """Read a schema stored as a JSON file, and translate that into a valid properties object for a notion DB.

    :param schema: The name/path of the JSON file where the schema is defined.
    :returns: A dictionary representing a valid properties value for a notion DB.
    """
    with open(schema, "r") as s:
        properties = json.load(s)
    return properties


def create_notion_db(parent_id, db_name: str, schema: str) -> Dict:
    """Create a notion DB on the page specified by PARENT_ID, structured according to SCHEMA, and return a Dict representing the constructed DB.

    :param parent_id: ID of the page to create the DB on.
    :param db_name: Intended name of the DB
    :param schema: Path to JSON file containing the schema for the DB

    :returns: Dictionary representing the database as a notion object
    """
    title = [{"type": "text", "text": {"content": db_name}}]
    icon = {"type": "emoji", "emoji": "ðŸŽ‰"}
    parent = {"type": "page_id", "page_id": parent_id}
    properties = read_properties_object(schema)
    return NOTION_CLIENT.databases.create(
        parent=parent, title=title, properties=properties, icon=icon
    )


def create_vuln_db(parent=NOTION_PAGE) -> str:
    """Create and populate a Notion DB of repo vulnerabilities on the specified page, and return the ID of the new DB. Also saves the ID of the new DB as the ID to use for populating the DB going forward.

    :param parent: ID of the notion page where the DB should be created

    :returns: ID of the created database.
    """
    database = create_notion_db(parent, "Vulnerabilities", VULN_SCHEMA)
    clear_last_update_time()  # We're creating a brand-new never-updated DB
    db_id = database["id"]
    populate_vuln_db(db_id)
    with open(NOTION_DB_PATH, "w") as f:
        f.write(db_id)
    return db_id


def populate_vuln_db(db_id=NOTION_DB) -> List[Dict]:
    """Given a pointer to a Notion DB, populate it with vulnerability data from both Dependabot and Snyk. Only add new vulnerabilities (those created since the last update)

    :param db_id: The ID of the Notion database to Populate

    :returns: A list of Page objects, each representing a created page/entry.
    """
    created_pages = []
    last_updated = get_last_update_time()
    new_alerts = filter(
        lambda alert: alert.created >= last_updated,
        GithubVulnerability.get_parsed_alerts(),
    )
    print(last_updated)
    for alert in new_alerts:
        properties = create_entry(alert)
        try:
            page = NOTION_CLIENT.pages.create(
                parent={"database_id": db_id}, properties=properties
            )
            created_pages.append(page)
        except Exception:
            print(f"Failed to create page: {alert}")

    set_last_update_time(datetime.now())
    return created_pages

def rebuild_vuln_db(db_id=NOTION_DB):
    """Like populate_vuln_db, but add all elements regardless of when they were discovered, and reset the last updated time.

    :param db_id:
    :returns:

    """
    clear_last_update_time()
    populate_vuln_db(db_id)



def get_last_update_time(path=UPDATE_FILE) -> str:
    try:
        with open(path, "r") as f:
            return f.read()
    except FileNotFoundError:
        return datetime.fromtimestamp(0).isoformat()


def set_last_update_time(time: datetime, path=UPDATE_FILE):
    with open(path, "w+") as f:
        f.write(time.isoformat())


def clear_last_update_time(path=UPDATE_FILE):
    set_last_update_time(datetime.fromtimestamp(0))


def wrap_in_rich_text(s: str, url: None | str = None) -> List[dict]:
    if url:
        return [
            {
                "type": "text",
                "text": {"content": s, "link": {"url": url}},
            },
        ]
    else:
        return [
            {
                "type": "text",
                "text": {"content": s},
            },
        ]


def create_entry(alert: Vulnerability) -> Dict:
    """Translate an alert into a Notion properties object that respects the vulnerability schema.

    :param alert: A Vulnerability object to be translated
    :returns: A dictionary containing the Vulnerability data, transformed to respect the schema of VULN_DB.

    """
    return {
        "Severity": {"select": {"name": alert.severity.to_string()}},
        "Package": {"rich_text": wrap_in_rich_text(alert.package.capitalize())},
        "Status": {"select": {"name": alert.state.to_string()}},
        "Date Discovered": {"date": {"start": alert.created}},
        "GHSA": {
            "rich_text": wrap_in_rich_text(
                alert.ghsa, f"https://github.com/advisories/{alert.ghsa}"
            )
        },
        "Patched Version": {"rich_text": wrap_in_rich_text(alert.fixed_version)},
        "Project": {"title": wrap_in_rich_text(alert.repo, alert.more_info)},
        "Summary": {"rich_text": wrap_in_rich_text(alert.summary)},
    }


def get_first_sentence(s: str) -> str:
    return s.split(".")[0]


def extract_repo_name(url: str) -> str:
    data = url.split("/repos/")[1]
    return data.split("/")[1]


def extract_user_name(url: str) -> str:
    data = url.split("/repos/")[1]
    return data.split("/")[0]


def flatten(lst: List[List]) -> List:
    return [item for sublist in lst for item in sublist]


def get_output(cmd: str) -> str:
    """Run a command in the default shell, and return the output as a string

    :param cmd: The command to run, as plaintext
    :returns: The output string from running the command (including intermediate output)

    """
    with Popen(cmd, stdout=PIPE, stderr=None, shell=True) as process:
        output = process.communicate()[0].decode("utf-8")
        return output


def main():
    """Retrieve GH and Snyk data, process into dataclasses, create notion DB, populate notion DB, open DB in web browser."""
    populate_vuln_db(NOTION_DB)  # Handles the GH vulnerabilities
    url = f"https://www.notion.so/{NOTION_DB}"
    webbrowser.open_new_tab(url)

clear_last_update_time()
main()
