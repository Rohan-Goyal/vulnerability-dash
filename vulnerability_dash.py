#!/usr/bin/env ipython3
from dataclasses import dataclass
from os import access
from pprint import pprint
from types import FunctionType
from typing import List
from github import Github
from subprocess import run
import json
from notion_client import Client
from notion_client.typing import SyncAsync
from notion_database.database import Database
from datetime import datetime, date

read_token = (
    lambda: "61092fbb-817d-40f8-be1f-0659358fb8ab"
)  # Placeholder for now, replace with more secure.
org_id = lambda: "cde0c9ab-d76d-4ef2-802c-5799b036f86f"
VULN_SCHEMA = "vuln_schema.json"


# client = snyk.SnykClient(read_token(), version="2022-02-16~experimental", url="https://api.snyk.io/rest")
# client = snyk.SnykClient(read_token())

# projects = client.get(f"/orgs/{org_id()}/projects").json()
# pprint(projects)


# client=snyk.SnykClient(read_token())

# org = client.organizations.get(org_id())

# projects = client.projects.all()
# for project in projects:
# print(project.vulnerabilities)
# TODO: Story for filtering out dismissed/ignored/solved.
GITHUB_TOKEN = lambda: ""
name = ""
gh = Github(GITHUB_TOKEN())
repo = gh.get_repo(name)
NOTION_TOKEN = "secret_rUv9VldkW1a17gLhfUo3LD4L2rrvAPEdEHsSt9mpTtb"
NOTION_DB = "3dc83c8f7f694d9480365705c3addb3d"

notion = Client(auth=NOTION_TOKEN)


def read_properties(schema: str) -> dict:
    """Read a schema stored as a JSON file, and translate that into a valid property object for a notion DB

    :param schema: The name/path of the JSON file where the schema is defined
    :returns: A dictionary representing a valid properties value for a notion DB.
    """
    with open(schema, "r") as s:
        properties = json.load(s)
        # TODO Optional json tinkering/processing
    return properties


def create_notion_db(parent_id, db_name: str, schema: str):
    """Create a notion DB on the page specified by PARENT_ID, structured according to SCHEMA, and return its ID
    :param parent_id:
    :param db_name:
    :param schema:
    :returns: TODO
    """
    title = [{"type": "text", "text": {"content": db_name}}]
    icon = {"type": "emoji", "emoji": "ğŸ‰"}
    parent = {"type": "page_id", "page_id": parent_id}
    properties = read_properties(schema)
    return notion.databases.create(
        parent=parent, title=title, properties=properties, icon=icon
    )


def get_id(db: SyncAsync) -> str:
    """Get the ID of a Notion database.

    :param db: Object representing a notion database as returned by the Notion Client.
    :returns: ID of that DB
    """
    return db.text["id"]


def create_vuln_db(parent):
    """TODO describe function

    :param parent:
    :returns:

    """
    database = create_notion_db(parent, "Vulnerabilities", VULN_SCHEMA)
    populate_vuln_db(get_id(database))
    return get_id(database)


def populate_vuln_db(db_id=NOTION_DB):
    """Given a pointer to a Notion DB, populate it with vulnerability data from both

    :param db_id:
    :returns:

    """
    for alert in GithubVulnerability.get_parsed_alerts(owner, repo):
        properties = create_entry(alert)
        notion.pages.create(database_id=db_id, properties=properties)


def create_entry(alert):
    """Translate an alert into a Notion properties object that respects the vulnerability schema.

    :param alert:
    :returns:

    """
    result = {}
    result["Project"]="TODO"
    result["Severity"]=


def create_fix_db(parent):
    database = create_notion_db(parent, "Recommended Fixes", FIX_SCHEMA)
    populate_fix_db(get_id(database))
    return get_id(database)


def populate_fix_db(db_id: str):
    pass


def get_first_sentence(s: str) -> str:
    return s.split(".")[0]


@dataclass
class Vulnerability:
    repo: str
    severity: int  # Scale from 1-5 probably
    summary: str
    package: str
    vulnerable_version: str
    state: str  # One of handled/dismissed/open
    created: datetime
    get_alerts: FunctionType
    parse_alert: FunctionType
    cve: str

    @classmethod
    def get_parsed_alerts(cls, owner, repo):
        for alert in cls.get_alerts(owner, repo):
            yield cls.parse_alert(alert)


@dataclass
class GithubVulnerability(Vulnerability):
    SEVERITY_SCORES = {
        "HIGH": 4,
    }  # TODO

    @staticmethod
    def get_alerts(owner: str, repo: str, token=GITHUB_TOKEN):
        """Get a list of Dependabot alerts as JSON. Uses curl as a hack because dependabot API is in public beta.


        :param owner:
        :param repo:
        :param token:
        :returns:

        """

        base = "https://api.github.com"
        endpoint = f"/repos/{owner}/{repo}/dependabot/alerts"
        command = f"""curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer {token}" -H "X-GitHub-Api-Version: 2022-11-28" {base+endpoint}"""
        result = run(command)
        out = json.loads(result.stdout)
        return out

    @staticmethod
    def score_severity(severity: str) -> int:
        return GithubVulnerability.SEVERITY_SCORES["severity"]

    @staticmethod
    def parse_alert(response: dict) -> Vulnerability:
        """Given a portion of the API response representing a single vulnerability, extract relevant fields and create a Vulnerability object.

        :param api_response:
        :returns: GitHubVulnerability object representing the passed-in dependabot alert.
        """
        repo = "TODO"
        state = response["state"]
        cve = "TODO"
        severity = GithubVulnerability.score_severity(response["severity"])
        summary = get_first_sentence(response["summary"])
        package = "TODO"
        created = datetime.fromisoformat(response["created_at"])
        return GithubVulnerability(
            repo=repo,
            state=state,
            severity=severity,
            summary=summary,
            package=package,
            created=created,
            vulnerable_version="TODO",
            cve=cve,
        )


@dataclass
class SnykVulnerability(Vulnerability):
    @staticmethod
    def get_alerts():
        """TODO describe function

        :returns:

        """

    pass
